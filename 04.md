NIP-04
======

Encrypted Direct Message
------------------------

`final` `optional` `author:arcbtc`

A special event with kind `4`, meaning "encrypted direct message". It is supposed to have the following attributes:

**`content`** MUST be equal to the base64-encoded, aes-256-gcm encrypted string of anything a user wants to write, encrypted using a shared cipher generated by combining the recipient's public-key with the sender's private-key, which is then processed with an hkdf using the normalized key and the salt; this appended by the base64-encoded initialization vector with a "%" delimiter. The format is the following: `"content": "<encrypted_text>%<initialization_vector>%<version>"`.   NOTE: pscs7 padding is used by default in webcrypto libraries, and is assumed to be part of the standard.

**`tags`** MUST contain an entry identifying the receiver of the message (such that relays may naturally forward this event to them), in the form `["p", "<pubkey, as a hex string>"]`.

**`tags`** MAY contain an entry identifying the previous message in a conversation or a message we are explicitly replying to (such that contextual, more organized conversations may happen), in the form `["e", "<event_id>"]`.

**Note**: By default in the [libsecp256k1](https://github.com/bitcoin-core/secp256k1) ECDH implementation, the secret is the SHA256 hash of the shared point (both X and Y coordinates). In version 0 of Nostr NIP4, only the X coordinate of the shared point is used as the secret and it is NOT hashed. If using libsecp256k1, a custom function that copies the X coordinate must be passed as the `hashfp` argument in `secp256k1_ecdh`. See [here](https://github.com/bitcoin-core/secp256k1/blob/master/src/modules/ecdh/main_impl.h#L29).  Failing to salt and hash this correctly in version zero causes a fixed-aes-key, and a 12 byte iv (4 bytes of the iv are ignored by AES-GCM).   In version 1 (below), these are salted, hashed, and gcm is used, a safer encryption standard.

Code sample for generating such an event in JavaScript:

```js
import crypto from 'crypto'
import * as secp from '@noble/secp256k1'
import { hkdf } from '@noble/hashes/hkdf';

let sharedPoint = secp.getSharedSecret(ourPrivateKey, '02' + theirPublicKey)
let sharedX = sharedPoint.slice(1, 33)
let iv = crypto.randomFillSync(new Uint8Array(16))
let key = hkdf(sha256, normalizedKey, iv, undefined, 32)
var cipher = crypto.createCipheriv(
  'aes-256-gcm',
  Buffer.from(key),
  iv
)
let encryptedMessage = cipher.update(text, 'utf8', 'base64')
encryptedMessage += cipher.final('base64')
let ivBase64 = Buffer.from(iv.buffer).toString('base64')

let event = {
  pubkey: ourPubKey,
  created_at: Math.floor(Date.now() / 1000),
  kind: 4,
  tags: [['p', theirPublicKey]],
  content: encryptedMessage + '%' + ivBase64 + "%1"
}
```


Code sample for decrypting both version 0 and version 1 events in JavaScript:

```js
import crypto from 'crypto'
import * as secp from '@noble/secp256k1'
import { hkdf } from '@noble/hashes/hkdf';

let [ctb64, ivb64, version] = data.split('%')
if (version != "1")
    [ctb64, ivb64] = data.split('?iv=')
let iv = base64.decode(ivb64)
let sharedPoint = secp.getSharedSecret(ourPrivateKey, '02' + theirPublicKey)
let sharedX = sharedPoint.slice(1, 33)
let key
if (version == "1")
    key = hkdf(sha256, normalizedKey, iv, undefined, 32)
else
    key = hkdf normalizedKey
var cipher = crypto.createDecipheriv(
  'aes-256-gcm',
  Buffer.from(key),
  iv
)
let decryptedMessage = cipher.update(ctb64, 'base64', 'utf8')
```

## Security Warning

This standard does not go anywhere near what is considered the state-of-the-art in encrypted communication between peers, but it does adhere to standards for encrypted archival stoage of data.  This standard leaks metadata in the events, consider only using in situations where metadata leakage (specifically the time, sender, recipient, and the approximate size of the message) is not a concern.

## Client Implementation Warning

Clients *should not* search and replace public key or note references from the `.content`. If processed like a regular text note (where `@npub...` is replaced with `#[0]` with a `["p", "..."]` tag) the tags are leaked and the mentioned user will receive the message in their inbox.
